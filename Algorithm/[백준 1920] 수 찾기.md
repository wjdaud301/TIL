## [백준 1920번] 수 찾기 :: Python



- **문제**

N개의 정수 A[1], A[2], …, A[N]이 주어져 있을 때, 이 안에 X라는 정수가 존재하는지 알아내는 프로그램을 작성하시오.



---



- **입력**

첫째 줄에 자연수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 줄에는 N개의 정수 A[1], A[2], …, A[N]이 주어진다. 다음 줄에는 M(1 ≤ M ≤ 100,000)이 주어진다. 다음 줄에는 M개의 수들이 주어지는데, 이 수들이 A안에 존재하는지 알아내면 된다. 모든 정수의 범위는 -231 보다 크거나 같고 231보다 작다.



---



- **출력**

M개의 줄에 답을 출력한다. 존재하면 1을, 존재하지 않으면 0을 출력한다.



---



- **예제 입력 1**

```
5
4 1 5 2 3
5
1 3 7 9 5
```

---



- **예제 출력 2**

```
1
1
0
0
1
```

---



- **코드 설명**

1. 시간복잡도에 의해 n * m을 할 경우 10억이 넘어가게 된다. 따라서 **이분탐색으로 시간복잡도를 줄인다.**
2. 이분탐색의 조건은 데이터가 **정렬**되어 있어야만 이분탐색이 가능하다

```python
def find(digit):
  # 처음과 끝의 인덱스 정의
  lt = 0
  rt = n-1
    
  # lt가 rt를 넘어가면 while문을 종료
  while lt <= rt:
    mid = (lt+rt)//2 	# mid 인덱스 정의
    if a[mid] == digit: # 찾았을 경우
      return 1
    elif digit < a[mid]: 	# digit이 중간 값보다 작을 경우 rt를 mid-1
      rt = mid-1
    else :					# # digit보다 중간 값보다 클 경우 lt를 mid+1
      lt = mid+1
  return 0


n = int(input())
a = list(map(int,input().split()))
a.sort()		# a의 데이터에 있는지 비교하기 때문에 a를 정렬시킨다.

m = int(input())
b = list(map(int,input().split()))


for i in b:
  print(find(i))
```



---

