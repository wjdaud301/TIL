## [Programmers] 2개 이하로 다른 비트

###### 

- **문제설명**

  

양의 정수 `x`에 대한 함수 `f(x)`를 다음과 같이 정의합니다.

- `x`보다 크고 `x`와 **비트가 1~2개 다른** 수들 중에서 제일 작은 수

예를 들어,

- `f(2) = 3` 입니다. 다음 표와 같이 2보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 3이기 때문입니다.

| 수   | 비트         | 다른 비트의 개수 |
| ---- | ------------ | ---------------- |
| 2    | `000...0010` |                  |
| 3    | `000...0011` | 1                |

- `f(7) = 11` 입니다. 다음 표와 같이 7보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 11이기 때문입니다.

| 수   | 비트         | 다른 비트의 개수 |
| ---- | ------------ | ---------------- |
| 7    | `000...0111` |                  |
| 8    | `000...1000` | 4                |
| 9    | `000...1001` | 3                |
| 10   | `000...1010` | 3                |
| 11   | `000...1011` | 2                |

정수들이 담긴 배열 `numbers`가 매개변수로 주어집니다. `numbers`의 모든 수들에 대하여 각 수의 `f` 값을 배열에 차례대로 담아 return 하도록 solution 함수를 완성해주세요.





- **제한 사항**
  - 1 ≤ `numbers`의 길이 ≤ 100,000
  - 0 ≤ `numbers`의 모든 수 ≤ 1015





- **입출력 예**

| numbers | result   |
| ------- | -------- |
| `[2,7]` | `[3,11]` |





- **코드 풀이**

```python
def solution(numbers): 
    answer = [] 
    for number in numbers: 
        # number가 2의 배수라면 첫째자리에 1을 추가
        if number % 2 == 0: 
            bi_num = list(bin(number)[2:]) 
            bi_num[-1] = "1"
        
        # 2의 배수가 아니라면 앞에 0을 추가
        else: 
            bi_num = bin(number)[2:] 
            bi_num = "0" + binary_num 
            # 오른쪽에서부터 0을 찾아 인덱스를 반환한다
            idx = binary_num.rfind("0") 
            bi_num = list(bi_num)
            # 0의 자리를 1로 바꾸고 다음 인덱스자리는 0으로 바꾼다.
            bi_num[idx] = "1" 
            bi_num[idx + 1] = "0" 
            
        # bianry number를 10진수로 변환하여 answer에 담는다    
        ans= int("".join(bi_num), 2) 
        answer.append(ans) 
        
    return answer

```

