## [Programmers] 쿼드압축 후 개수 새기



- **문제 설명**

0과 1로 이루어진 2n x 2n 크기의 2차원 정수 배열 arr이 있습니다. 당신은 이 arr을 쿼드 트리와 같은 방식으로 압축하고자 합니다. 구체적인 방식은 다음과 같습니다.

1. 당신이 압축하고자 하는 특정 영역을 S라고 정의합니다.
2. 만약 S 내부에 있는 모든 수가 같은 값이라면, S를 해당 수 하나로 압축시킵니다.
3. 그렇지 않다면, S를 정확히 4개의 균일한 정사각형 영역(입출력 예를 참고해주시기 바랍니다.)으로 쪼갠 뒤, 각 정사각형 영역에 대해 같은 방식의 압축을 시도합니다.

arr이 매개변수로 주어집니다. 위와 같은 방식으로 arr을 압축했을 때, 배열에 최종적으로 남는 0의 개수와 1의 개수를 배열에 담아서 return 하도록 solution 함수를 완성해주세요.





- **제한 사항**

- arr의 행의 개수는 1 이상 1024 이하이며, 2의 거듭 제곱수 형태를 하고 있습니다. 즉, arr의 행의 개수는 1, 2, 4, 8, ..., 1024 중 하나입니다.
  - arr의 각 행의 길이는 arr의 행의 개수와 같습니다. 즉, arr은 정사각형 배열입니다.
  - arr의 각 행에 있는 모든 값은 0 또는 1 입니다.





- **입출력 예시**

| arr                                                          | result    |
| ------------------------------------------------------------ | --------- |
| `[[1,1,0,0],[1,0,0,0],[1,0,0,1],[1,1,1,1]]`                  | `[4,9]`   |
| `[[1,1,1,1,1,1,1,1],[0,1,1,1,1,1,1,1],[0,0,0,0,1,1,1,1],[0,1,0,0,1,1,1,1],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,0,1],[0,0,0,0,1,0,0,1],[0,0,0,0,1,1,1,1]]` | `[10,15]` |





- **입출력  예 설명**

- 다음 그림은 주어진 arr을 압축하는 과정을 나타낸 것입니다.
- ![ex1.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/d6900862-8be4-4610-aaef-bc8efd5650cf/ex1.png)
- 최종 압축 결과에 0이 4개, 1이 9개 있으므로, `[4,9]`를 return 해야 합니다.

입출력 예 #2

- 다음 그림은 주어진 arr을 압축하는 과정을 나타낸 것입니다.
- ![ex2.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/952a05b7-5157-4211-82d9-02845c187e13/ex2.png)
- 최종 압축 결과에 0이 10개, 1이 15개 있으므로, `[10,15]`를 return 해야 합니다.

---



- **코드 풀이**

```python
answer = [0,0]

def split(arr):
    part1, part2, part3, part4 = [],[],[],[]
    p1,p2,p3,p4 = 0,0,0,0
    l = len(arr) // 2
	
    # 4개의 구역으로 쪼갠 뒤 구역마다 전체 값의 합을 저장
    if len(arr) > 1:
        for i in arr[:l]:
            part1.append(i[:l])
            p1 += sum(i[:l])
            part2.append(i[l:])
            p2 += sum(i[l:])
        for i in arr[l:]:
            part3.append(i[:l])
            p3 += sum(i[:l])
            part4.append(i[l:])
            p4 += sum(i[l:])

        # 구역마다 전체가 1인경우와 0인경우를 고려한다.
        # 구역안에 1과 0이 섞여 있을 경우 재귀함수를 통해 그 구역을 다시 split()함수 진행
        if p1 == l*l: answer[1] += 1
        elif p1 == 0 : answer[0] += 1
        else: split(part1)
            
        if p2 == l*l: answer[1] += 1
        elif p2 == 0 : answer[0] += 1
        else: split(part2)
            
        if p3 == l*l: answer[1] += 1
        elif p3 == 0 : answer[0] += 1
        else: split(part3)
            
        if p4 == l*l: answer[1] += 1
        elif p4 == 0 : answer[0] += 1
        else: split(part4)
            
        
    else:
        # 마지막까지 쪼개졌지만 압축이 되지않은 것들에대하여 0과 1을 고려해서 추가한다.
        answer[0] += (arr[0] + arr[1] ).count(0)
        answer[1] += (arr[0] + arr[1] ).count(1)
    return answer

def solution(arr):
    # DFS알고리즘을 사용하여 쪼갤 수 없을 때까지 4개로 쪼개기 반복
    ans = split(arr)
    
    # 전체가 0이거나 1인 경우를 고려
    if ans[0] == 0:
        ans[1] = 1
        return ans
    elif ans[1] == 0:
        ans[0] = 1
        return ans
    else:
        return ans
```

